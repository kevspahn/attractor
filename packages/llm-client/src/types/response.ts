/**
 * Response types for the unified LLM client.
 */

import type { ContentPart, Message, ThinkingContentPart } from "./message.js";
import { ContentKind } from "./enums.js";
import type { ToolCall } from "./tool.js";

// ---------------------------------------------------------------------------
// FinishReason (Section 3.8)
// ---------------------------------------------------------------------------

/**
 * A dual representation preserving both portable semantics and
 * provider-specific detail.
 *
 * Unified reason values: stop, length, tool_calls, content_filter, error, other.
 */
export interface FinishReason {
  /** Unified reason value. */
  readonly reason: string;
  /** The provider's native finish reason string. */
  readonly raw?: string;
}

// ---------------------------------------------------------------------------
// Usage (Section 3.9) â€” a class so it can have an `add` method
// ---------------------------------------------------------------------------

/** Token counts for a request/response cycle. */
export class Usage {
  /** Tokens in the prompt. */
  readonly input_tokens: number;
  /** Tokens generated by the model. */
  readonly output_tokens: number;
  /** input + output. */
  readonly total_tokens: number;
  /** Tokens used for chain-of-thought reasoning. */
  readonly reasoning_tokens?: number;
  /** Tokens served from prompt cache. */
  readonly cache_read_tokens?: number;
  /** Tokens written to prompt cache. */
  readonly cache_write_tokens?: number;
  /** Raw provider usage data. */
  readonly raw?: Record<string, unknown>;

  constructor(fields: {
    input_tokens: number;
    output_tokens: number;
    total_tokens?: number;
    reasoning_tokens?: number;
    cache_read_tokens?: number;
    cache_write_tokens?: number;
    raw?: Record<string, unknown>;
  }) {
    this.input_tokens = fields.input_tokens;
    this.output_tokens = fields.output_tokens;
    this.total_tokens =
      fields.total_tokens ?? fields.input_tokens + fields.output_tokens;
    this.reasoning_tokens = fields.reasoning_tokens;
    this.cache_read_tokens = fields.cache_read_tokens;
    this.cache_write_tokens = fields.cache_write_tokens;
    this.raw = fields.raw;
  }

  /**
   * Add two Usage objects together.
   *
   * Integer fields are summed. For optional fields: if either side is
   * non-undefined, they are summed (treating undefined as 0). If both sides
   * are undefined, the result is undefined.
   */
  add(other: Usage): Usage {
    return new Usage({
      input_tokens: this.input_tokens + other.input_tokens,
      output_tokens: this.output_tokens + other.output_tokens,
      total_tokens: this.total_tokens + other.total_tokens,
      reasoning_tokens: addOptional(
        this.reasoning_tokens,
        other.reasoning_tokens,
      ),
      cache_read_tokens: addOptional(
        this.cache_read_tokens,
        other.cache_read_tokens,
      ),
      cache_write_tokens: addOptional(
        this.cache_write_tokens,
        other.cache_write_tokens,
      ),
    });
  }
}

/**
 * Add two optional numbers: if either is non-undefined, sum them (treating
 * undefined as 0). If both are undefined, return undefined.
 */
function addOptional(
  a: number | undefined,
  b: number | undefined,
): number | undefined {
  if (a === undefined && b === undefined) return undefined;
  return (a ?? 0) + (b ?? 0);
}

// ---------------------------------------------------------------------------
// Warning (Section 3.11)
// ---------------------------------------------------------------------------

/** A non-fatal issue in a response. */
export interface Warning {
  /** Human-readable description of the non-fatal issue. */
  readonly message: string;
  /** Machine-readable warning code. */
  readonly code?: string;
}

// ---------------------------------------------------------------------------
// RateLimitInfo (Section 3.12)
// ---------------------------------------------------------------------------

/** Rate limit metadata from provider response headers. */
export interface RateLimitInfo {
  readonly requests_remaining?: number;
  readonly requests_limit?: number;
  readonly tokens_remaining?: number;
  readonly tokens_limit?: number;
  readonly reset_at?: Date;
}

// ---------------------------------------------------------------------------
// Response (Section 3.7)
// ---------------------------------------------------------------------------

/** The output from a `complete()` call. */
export interface Response {
  /** Provider-assigned response ID. */
  readonly id: string;
  /** Actual model used (may differ from requested). */
  readonly model: string;
  /** Which provider fulfilled the request. */
  readonly provider: string;
  /** The assistant's response as a Message. */
  readonly message: Message;
  /** Why generation stopped. */
  readonly finish_reason: FinishReason;
  /** Token counts. */
  readonly usage: Usage;
  /** Raw provider response JSON (for debugging). */
  readonly raw?: Record<string, unknown>;
  /** Non-fatal issues. */
  readonly warnings?: readonly Warning[];
  /** Rate limit metadata from headers. */
  readonly rate_limit?: RateLimitInfo;
}

// ---------------------------------------------------------------------------
// Convenience accessors (standalone functions)
// ---------------------------------------------------------------------------

/** Get concatenated text from a Response's message. */
export function getResponseText(response: Response): string {
  return response.message.content
    .filter(
      (part): part is ContentPart & { kind: typeof ContentKind.TEXT } =>
        part.kind === ContentKind.TEXT,
    )
    .map((part) => part.text)
    .join("");
}

/** Extract tool calls from a Response's message content parts. */
export function getResponseToolCalls(response: Response): ToolCall[] {
  return response.message.content
    .filter(
      (
        part,
      ): part is ContentPart & { kind: typeof ContentKind.TOOL_CALL } =>
        part.kind === ContentKind.TOOL_CALL,
    )
    .map((part) => ({
      id: part.tool_call.id,
      name: part.tool_call.name,
      arguments:
        typeof part.tool_call.arguments === "string"
          ? (JSON.parse(part.tool_call.arguments) as Record<string, unknown>)
          : part.tool_call.arguments,
      raw_arguments:
        typeof part.tool_call.arguments === "string"
          ? part.tool_call.arguments
          : undefined,
    }));
}

/** Get concatenated reasoning/thinking text from a Response's message. */
export function getResponseReasoning(response: Response): string | undefined {
  const parts = response.message.content.filter(
    (part): part is ThinkingContentPart =>
      part.kind === ContentKind.THINKING ||
      part.kind === ContentKind.REDACTED_THINKING,
  );
  if (parts.length === 0) return undefined;
  return parts.map((part) => part.thinking.text).join("");
}
